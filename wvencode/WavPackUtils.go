package wvencode

/*
** WavPackUtils.go
**
** Copyright (c) 2013 Peter McQuillan
**
** All Rights Reserved.
**
** Distributed under the BSD Software License (see license.txt)
**
 */

///////////////////////////// local table storage ////////////////////////////
var sample_rates = [15]uint{6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000}


// This function returns a pointer to a string describing the last error
// generated by WavPack.
func WavpackGetErrorMessage(wpc *WavpackContext) string {
	return wpc.error_message
}


// Set configuration for writing WavPack files. This must be done before
// sending any actual samples. The "config" structure contains the following
// required information:
// config.bytes_per_sample     see WavpackGetBytesPerSample() for info
// config.bits_per_sample      see WavpackGetBitsPerSample() for info
// config.num_channels         self evident
// config.sample_rate          self evident
// In addition, the following fields and flags may be set: 
// config->flags:
// --------------
// o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate)
// o CONFIG_JOINT_STEREO        select joint stereo (must set override also)
// o CONFIG_JOINT_OVERRIDE      override default joint stereo selection
// o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &
//                                                      shaping_weight != 0)
// o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping
//                               (set CONFIG_HYBRID_SHAPE and shaping_weight)
// o CONFIG_FAST_FLAG           "fast" compression mode
// o CONFIG_HIGH_FLAG           "high" compression mode
// o CONFIG_VERY_HIGH_FLAG      "very high" compression mode
// o CONFIG_CREATE_WVC          create correction file
// o CONFIG_OPTIMIZE_WVC        maximize bybrid compression (-cc option)
// config->bitrate              hybrid bitrate in bits/sample (scaled up 2^8)
// config->shaping_weight       hybrid noise shaping coefficient (scaled up 2^10)
// config->block_samples        force samples per WavPack block (0 = use deflt)
// If the number of samples to be written is known then it should be passed
// here. If the duration is not known then pass -1. In the case that the size
// is not known (or the writing is terminated early) then it is suggested that
// the application retrieve the first block written and let the library update
// the total samples indication. A function is provided to do this update and
// it should be done to the "correction" file also. If this cannot be done
// (because a pipe is being used, for instance) then a valid WavPack will still
// be created, but when applications want to access that file they will have
// to seek all the way to the end to determine the actual duration. A return of
// FALSE indicates an error.
func WavpackSetConfiguration(wpc *WavpackContext, config *WavpackConfig, total_samples uint) int {
	var flags uint = uint(config.Bytes_per_sample - 1)
	var wps WavpackStream = wpc.stream
	var bps int = 0
	var shift uint
	var i uint

	if config.Num_channels > 2 {
		wpc.error_message = "too many channels!"

		return FALSE
	}

	wps.blockend = BIT_BUFFER_SIZE  // need to initialise this
	wps.block2end = BIT_BUFFER_SIZE // and initialise this

	wpc.total_samples = total_samples
	wpc.config.Sample_rate = config.Sample_rate
	wpc.config.Num_channels = config.Num_channels
	wpc.config.Bits_per_sample = config.Bits_per_sample
	wpc.config.Bytes_per_sample = config.Bytes_per_sample
	wpc.config.Block_samples = config.Block_samples
	wpc.config.Flags = config.Flags

	if (wpc.config.Flags & CONFIG_VERY_HIGH_FLAG) > 0 {
		wpc.config.Flags |= CONFIG_HIGH_FLAG
	}

	shift = uint((config.Bytes_per_sample * 8) - config.Bits_per_sample)

	for i = 0; i < 15; i++ {
		if wpc.config.Sample_rate == sample_rates[i] {
			break
		}
	}

	flags |= (i << SRATE_LSB)
	flags |= (shift << SHIFT_LSB)

	if (config.Flags & CONFIG_HYBRID_FLAG) != 0 {
		flags |= (HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE)

		if ((wpc.config.Flags & CONFIG_SHAPE_OVERRIDE) != 0) &&
			((wpc.config.Flags & CONFIG_HYBRID_SHAPE) != 0) &&
			(config.Shaping_weight != 0) {
			wpc.config.Shaping_weight = config.Shaping_weight
			flags |= (HYBRID_SHAPE | NEW_SHAPING)
		}

		if (wpc.config.Flags & CONFIG_OPTIMIZE_WVC) != 0 {
			flags |= CROSS_DECORR
		}

		bps = config.Bitrate
	} else {
		flags |= CROSS_DECORR
	}

	if ((config.Flags & CONFIG_JOINT_OVERRIDE) == 0) ||
		((config.Flags & CONFIG_JOINT_STEREO) != 0) {
		flags |= JOINT_STEREO
	}

	if (config.Flags & CONFIG_CREATE_WVC) != 0 {
		wpc.wvc_flag = TRUE
	}

	wpc.stream_version = CUR_STREAM_VERS

	wps.wphdr.ckID[0] = 'w'
	wps.wphdr.ckID[1] = 'v'
	wps.wphdr.ckID[2] = 'p'
	wps.wphdr.ckID[3] = 'k'

	// 32 is the size of the WavPack header
	wps.wphdr.ckSize = 32 - 8
	wps.wphdr.total_samples = wpc.total_samples
	wps.wphdr.version = wpc.stream_version
	wps.wphdr.flags = flags | INITIAL_BLOCK | FINAL_BLOCK
	wps.bits = bps

	if config.Num_channels == 1 {
		wps.wphdr.flags &= ^(JOINT_STEREO | CROSS_DECORR |
			HYBRID_BALANCE)
		wps.wphdr.flags |= MONO_FLAG
	}

	wpc.stream = wps

	return TRUE
}


// Prepare to actually pack samples by determining the size of the WavPack
// blocks and initializing the stream. Call after WavpackSetConfiguration()
// and before WavpackPackSamples(). A return of FALSE indicates an error.
func WavpackPackInit(wpc *WavpackContext) int {
	if wpc.config.Block_samples > 0 {
		wpc.block_samples = wpc.config.Block_samples
	} else {
		if (wpc.config.Flags & CONFIG_HIGH_FLAG) > 0 {
			wpc.block_samples = wpc.config.Sample_rate
		} else if (wpc.config.Sample_rate % 2) == 0 {
			wpc.block_samples = wpc.config.Sample_rate / 2
		} else {
			wpc.block_samples = wpc.config.Sample_rate
		}

		for (wpc.block_samples * wpc.config.Num_channels) > 150000 {
			wpc.block_samples /= 2
		}

		for (wpc.block_samples * wpc.config.Num_channels) < 40000 {
			wpc.block_samples *= 2
		}
	}

	pack_init(wpc)

	return TRUE
}


// Pack the specified samples. Samples must be stored in longs in the native
// endian format of the executing processor. The number of samples specified
// indicates composite samples (sometimes called "frames"). So, the actual
// number of data points would be this "sample_count" times the number of
// channels. Note that samples are immediately packed into the block(s)
// currently being built. If the predetermined number of sample per block
// is reached, or the block being built is approaching overflow, then the
// block will be completed and written. If an application wants to break a
// block at a specific sample, then it must simply call WavpackFlushSamples()
// to force an early termination. Completed WavPack blocks are send to the
// function provided in the initial call to WavpackOpenFileOutput(). A
// return of FALSE indicates an error.
func WavpackPackSamples(wpc *WavpackContext, sample_buffer []int, sample_count uint) int {
	var wps WavpackStream = wpc.stream
	var flags uint = wps.wphdr.flags

	if (flags & SHIFT_MASK) != 0 {
		shift := (uint)((flags & SHIFT_MASK) >> SHIFT_LSB)
		ptr := sample_buffer[0:len(sample_buffer)]
		cnt := sample_count
		ptrIndex := 0

		if (flags & (MONO_FLAG | FALSE_STEREO)) != 0 {
			for cnt > 0 {
				ptr[ptrIndex] = ptr[ptrIndex] >> shift
				ptrIndex++
				cnt--
			}
		} else {
			for cnt > 0 {
				ptr[ptrIndex] = ptr[ptrIndex] >> shift
				ptrIndex++
				ptr[ptrIndex] = ptr[ptrIndex] >> shift
				ptrIndex++
				cnt--
			}
		}
	}

	for sample_count > 0 {
		var samples_to_pack uint
		var samples_packed uint

		if wpc.acc_samples == 0 {
			flags &= ^MAG_MASK
			flags += ((1 << MAG_LSB) * (((flags & BYTES_STORED) * 8) + 7))

			wps.wphdr.block_index = wps.sample_index
			wps.wphdr.flags = flags
			wpc.stream = wps
			pack_start_block(wpc)
		}

		if (wpc.acc_samples + sample_count) > wpc.block_samples {
			samples_to_pack = wpc.block_samples - wpc.acc_samples
		} else {
			samples_to_pack = sample_count
		}

		samples_packed = pack_samples(wpc, sample_buffer, samples_to_pack)
		wps = wpc.stream

		sample_count -= samples_packed

		wpc.acc_samples += samples_packed
		if (wpc.acc_samples == wpc.block_samples) ||
			(samples_packed != samples_to_pack) {
			if finish_block(wpc) == 0 {
				return FALSE
			}
		}
		wps = wpc.stream
	}

	return TRUE
}


// Flush all accumulated samples into WavPack blocks. This is normally called
// after all samples have been sent to WavpackPackSamples(), but can also be
// called to terminate a WavPack block at a specific sample (in other words it
// is possible to continue after this operation). A return of FALSE indicates
// an error.
func WavpackFlushSamples(wpc *WavpackContext) int {
	if (wpc.acc_samples != 0) && (finish_block(wpc) == 0) {
		return FALSE
	}

	return TRUE
}

func finish_block(wpc *WavpackContext) int {
	var wps WavpackStream = wpc.stream
	var bcount uint
	var result int = 0

	result = pack_finish_block(wpc)

	wpc.acc_samples = 0

	if result == 0 {
		wpc.error_message = "output buffer overflowed!"

		return result
	}

	bcount = uint((int(wps.blockbuff[4]) & 0xff) + ((int(wps.blockbuff[5]) & 0xff) << 8) +
		((int(wps.blockbuff[6]) & 0xff) << 16) + ((int(wps.blockbuff[7]) & 0xff) << 24) + 8)

	outputArray := wps.blockbuff[0:bcount]
	written, err := wpc.Outfile.Write(outputArray)

	if written != int(bcount) {
		// amount of bytes written was less than expected
		result = FALSE
	}

	if err != nil {
		result = FALSE
	}

	if result == 0 {
		wpc.error_message = "can't write WavPack data, disk probably full!"

		return result
	}

	wpc.filelen += bcount

	if wps.block2buff[0] == 'w' { // if starts with w then has a WavPack header i.e. it is defined 
		bcount = uint(int(wps.block2buff[4]&0xff) + (int(wps.block2buff[5]&0xff) << 8) +
			(int(wps.block2buff[6]&0xff) << 16) + (int(wps.block2buff[7]&0xff) << 24) + 8)

		outputCorrectionArray := wps.block2buff[0:bcount]
		written1, err1 := wpc.Correction_outfile.Write(outputCorrectionArray)

		if written1 != int(bcount) {
			// amount of bytes written was less than expected
			result = FALSE
		}

		if err1 != nil {
			result = FALSE
		}

		if result == 0 {
			wpc.error_message = "can't write WavPack data, disk probably full!"

			return result
		}

		wpc.file2len += bcount
	}

	return result
}

// Get total number of samples contained in the WavPack file, or -1 if unknown
func WavpackGetNumSamples(wpc *WavpackContext) int {
	if nil != wpc {
		return int(wpc.total_samples)
	}
	return (-1)
}

// Get the current sample index position, or -1 if unknown
func WavpackGetSampleIndex(wpc *WavpackContext) int {
	if nil != wpc {
		return wpc.stream.sample_index
	}

	return -1
}
/*
   // Returns the sample rate of the specified WavPack file
   static long WavpackGetSampleRate(wpc *WavpackContext)
   {
       if (null != wpc)
       {
           return (wpc.config.sample_rate);
       }
       else
       {
           return (long) 44100;
       }
   }
*/
// Returns the number of channels of the specified WavPack file.
func WavpackGetNumChannels(wpc *WavpackContext) int {
	if nil != wpc {
		return int(wpc.config.Num_channels)
	}

	return 2
}
/*
   // Returns the actual number of valid bits per sample contained in the
   // original file from 1 to 24, and which may or may not be a multiple
   // of 8. When this value is not a multiple of 8, then the "extra" bits
   // are located in the LSBs of the results. That is, values are right
   // justified when unpacked into ints, but are left justified in the
   // number of bytes used by the original data.
   static int WavpackGetBitsPerSample(WavpackContext wpc)
   {
       if (null != wpc)
       {
           return (wpc.config.bits_per_sample);
       }
       else
       {
           return 16;
       }
   }
*/
// Returns the number of bytes used for each sample (1 to 4) in the original
// file. This is required information for the user of this module because the
// audio data is returned in the LOWER bytes of the long buffer and must be
// left-shifted 8, 16, or 24 bits if normalized longs are required.
func WavpackGetBytesPerSample(wpc *WavpackContext) int {
	if nil != wpc {
		return (wpc.config.Bytes_per_sample)
	}
	return 2
}
